diff --git a/Makefile b/Makefile
index b4940cd..fb26666 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,6 @@
-CONTAINER_COMMAND = $(shell if [ -x "$(shell which docker)" ];then echo "docker" ; else echo "podman";fi)
-INSTALLER := $(or ${INSTALLER},quay.io/ocpmetal/assisted-installer:stable)
-CONTROLLER :=  $(or ${CONTROLLER}, quay.io/ocpmetal/assisted-installer-controller:stable)
+CONTAINER_COMMAND = podman
+INSTALLER := $(or ${INSTALLER},quay.io/otuchfel/assisted-installer:swarm)
+CONTROLLER :=  $(or ${CONTROLLER}, quay.io/otuchfel/assisted-installer-controller:swarm)
 ROOT_DIR = $(shell dirname $(realpath $(firstword $(MAKEFILE_LIST))))
 NAMESPACE := $(or ${NAMESPACE},assisted-installer)
 GIT_REVISION := $(shell git rev-parse HEAD)
diff --git a/go.mod b/go.mod
index 34621e5..7f18d7b 100644
--- a/go.mod
+++ b/go.mod
@@ -47,6 +47,7 @@ replace (
 	k8s.io/api => k8s.io/api v0.19.2
 	k8s.io/apimachinery => k8s.io/apimachinery v0.19.2
 	k8s.io/client-go => k8s.io/client-go v0.19.2
+	github.com/irifrance/gini => github.com/go-air/gini v1.0.1
 	k8s.io/code-generator => k8s.io/code-generator v0.0.0-20200214080538-dc8f3adce97c
 	sigs.k8s.io/cluster-api-provider-aws => github.com/openshift/cluster-api-provider-aws v0.2.1-0.20201022175424-d30c7a274820
 	sigs.k8s.io/cluster-api-provider-azure => github.com/openshift/cluster-api-provider-azure v0.1.0-alpha.3.0.20201016155852-4090a6970205
diff --git a/go.sum b/go.sum
index 9da6317..56cbbf5 100644
--- a/go.sum
+++ b/go.sum
@@ -394,6 +394,7 @@ github.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm
 github.com/gin-gonic/gin v1.6.3/go.mod h1:75u5sXoLsGZoRN5Sgbi1eraJ4GU3++wFwWzhwvtwp4M=
 github.com/globalsign/mgo v0.0.0-20180905125535-1ca0a4f7cbcb/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=
 github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=
+github.com/go-air/gini v1.0.1/go.mod h1:swH5OTtiG/X/YrU06r288qZwq6I1agpbuXQOB55xqGU=
 github.com/go-bindata/go-bindata v3.1.2+incompatible/go.mod h1:xK8Dsgwmeed+BBsSy2XTopBn/8uK2HWuGSnA11C3Joo=
 github.com/go-bindata/go-bindata/v3 v3.1.3/go.mod h1:1/zrpXsLD8YDIbhZRqXzm1Ghc7NhEvIN9+Z6R5/xH4I=
 github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=
diff --git a/src/assisted_installer_controller/assisted_installer_controller.go b/src/assisted_installer_controller/assisted_installer_controller.go
index e653b71..7ccb221 100644
--- a/src/assisted_installer_controller/assisted_installer_controller.go
+++ b/src/assisted_installer_controller/assisted_installer_controller.go
@@ -355,16 +355,18 @@ func (c *controller) ApproveCsrs(ctx context.Context) {
 	c.log.Infof("Start approving CSRs")
 	ticker := time.NewTicker(GeneralWaitInterval)
 	for {
+        csrs, err := c.kc.ListCsrs()
+        if err != nil {
+            continue
+        }
+        c.approveCsrs(csrs)
+
 		select {
 		case <-ctx.Done():
 			c.log.Infof("Finish approving CSRs")
 			return
 		case <-ticker.C:
-			csrs, err := c.kc.ListCsrs()
-			if err != nil {
-				continue
-			}
-			c.approveCsrs(csrs)
+		    continue
 		}
 	}
 }
@@ -1193,7 +1195,7 @@ func (c controller) SetReadyState() {
 			c.log.WithError(err).Warningf("Failed to connect to assisted service")
 			return false
 		}
-		c.log.Infof("assisted-service is available")
+		c.log.Infof("assisted-service is available %+v")
 
 		_, err = c.kc.ListNodes()
 		if err != nil {
diff --git a/src/common/common.go b/src/common/common.go
index a8c1ed1..9fbac31 100644
--- a/src/common/common.go
+++ b/src/common/common.go
@@ -39,6 +39,7 @@ func SetConfiguringStatusForHosts(client inventory_client.InventoryClient, inven
 	if fromBootstrap {
 		notValidStates[models.HostStageWaitingForIgnition] = struct{}{}
 	}
+    log.Infof("Hosts: %+v", inventoryHostsMapWithIp)
 	for hostName, host := range inventoryHostsMapWithIp {
 		_, ok := notValidStates[host.Host.Progress.CurrentStage]
 		if ok {
diff --git a/src/installer/installer.go b/src/installer/installer.go
index b555868..f183e0b 100644
--- a/src/installer/installer.go
+++ b/src/installer/installer.go
@@ -149,9 +149,9 @@ func (i *installer) InstallNode() error {
 	//update installation progress
 	i.UpdateHostInstallProgress(models.HostStageRebooting, "")
 	//reboot
-	if err = i.ops.Reboot(); err != nil {
-		return err
-	}
+	// if err = i.ops.Reboot(); err != nil {
+	// 	return err
+	// }
 	return nil
 }
 
@@ -207,35 +207,35 @@ func (i *installer) startBootstrap() error {
 		return err
 	}
 	ignitionFileName := "bootstrap.ign"
-	ignitionPath, err := i.getFileFromService(ignitionFileName)
+	_, err := i.getFileFromService(ignitionFileName)
 	if err != nil {
 		return err
 	}
 
 	// We need to extract pull secret from ignition and save it in docker config
 	// to be able to pull MCO official image
-	if err = i.ops.ExtractFromIgnition(ignitionPath, dockerConfigFile); err != nil {
-		return err
-	}
+	// if err = i.ops.ExtractFromIgnition(ignitionPath, dockerConfigFile); err != nil {
+	// 	return err
+	// }
 
-	err = i.extractIgnitionToFS(ignitionPath)
+	// err = i.extractIgnitionToFS(ignitionPath)
 	if err != nil {
 		return err
 	}
 
 	if i.HighAvailabilityMode != models.ClusterHighAvailabilityModeNone {
-		err = i.generateSshKeyPair()
+		// err = i.generateSshKeyPair()
 		if err != nil {
 			return err
 		}
-		err = i.ops.CreateOpenshiftSshManifest(assistedInstallerSshManifest, sshManifestTmpl, sshPubKeyPath)
+		// err = i.ops.CreateOpenshiftSshManifest(assistedInstallerSshManifest, sshManifestTmpl, sshPubKeyPath)
 		if err != nil {
 			return err
 		}
 	}
 
 	// reload systemd configurations from filesystem and regenerate dependency trees
-	err = i.ops.SystemctlAction("daemon-reload")
+	// err = i.ops.SystemctlAction("daemon-reload")
 	if err != nil {
 		return err
 	}
@@ -245,14 +245,14 @@ func (i *installer) startBootstrap() error {
 	   remove the work done by 30-local-dns-prepender. This will cause DNS issue in bootkube and it will fail to complete
 	   successfully
 	*/
-	err = i.checkLocalhostName()
+	// err = i.checkLocalhostName()
 	if err != nil {
 		i.log.Error(err)
 		return err
 	}
 
 	// restart NetworkManager to trigger NetworkManager/dispatcher.d/30-local-dns-prepender
-	err = i.ops.SystemctlAction("restart", "NetworkManager.service")
+	// err = i.ops.SystemctlAction("restart", "NetworkManager.service")
 	if err != nil {
 		i.log.Error(err)
 		return err
@@ -263,7 +263,7 @@ func (i *installer) startBootstrap() error {
 		return err
 	}
 
-	servicesToStart := []string{"bootkube.service", "approve-csr.service", "progress.service"}
+	servicesToStart := []string{}
 	for _, service := range servicesToStart {
 		err = i.ops.SystemctlAction("start", service)
 		if err != nil {
@@ -669,14 +669,14 @@ func (i *installer) cleanupInstallDevice() error {
 		return nil
 	}
 
-	err = i.ops.RemoveVG(vgName)
+	// err = i.ops.RemoveVG(vgName)
 	if err != nil {
 		return err
 	}
 
-	_ = i.ops.Wipefs(i.Device)
+	// _ = i.ops.Wipefs(i.Device)
 
-	return i.ops.RemovePV(i.Device)
+	return err // i.ops.RemovePV(i.Device)
 }
 
 func (i *installer) verifyHostCanMoveToConfigurationStatus(inventoryHostsMapWithIp map[string]inventory_client.HostData) {
@@ -743,7 +743,7 @@ func (i *installer) createSingleNodeMasterIgnition() (string, error) {
 		return "", err
 	}
 	i.Config.Role = string(models.HostRoleMaster)
-	err = i.updateSingleNodeIgnition(singleNodeMasterIgnitionPath)
+	// err = i.updateSingleNodeIgnition(singleNodeMasterIgnitionPath)
 	if err != nil {
 		return "", err
 	}
diff --git a/src/main/assisted-installer-controller/assisted_installer_main.go b/src/main/assisted-installer-controller/assisted_installer_main.go
index 73ec8d4..324f9da 100644
--- a/src/main/assisted-installer-controller/assisted_installer_main.go
+++ b/src/main/assisted-installer-controller/assisted_installer_main.go
@@ -1,6 +1,7 @@
 package main
 
 import (
+    "bytes"
 	"context"
 	"log"
 	"os"
@@ -9,6 +10,8 @@ import (
 
 	"github.com/kelseyhightower/envconfig"
 	assistedinstallercontroller "github.com/openshift/assisted-installer/src/assisted_installer_controller"
+	"github.com/golang/mock/gomock"
+	. "github.com/onsi/ginkgo"
 	"github.com/openshift/assisted-installer/src/inventory_client"
 	"github.com/openshift/assisted-installer/src/k8s_client"
 	"github.com/openshift/assisted-installer/src/ops"
@@ -17,6 +20,12 @@ import (
 	"github.com/openshift/assisted-service/models"
 	"github.com/openshift/assisted-service/pkg/secretdump"
 	"github.com/sirupsen/logrus"
+	metal3v1alpha1 "github.com/metal3-io/baremetal-operator/pkg/apis/metal3/v1alpha1"
+
+	v1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	certificatesv1 "k8s.io/api/certificates/v1"
+	machinev1beta1 "github.com/openshift/machine-api-operator/pkg/apis/machine/v1beta1"
 )
 
 // Added this way to be able to test it
@@ -31,6 +40,75 @@ var Options struct {
 
 const maximumErrorsBeforeExit = 3
 
+func prepareSwarmMock(mockk8sclient *k8s_client.MockK8SClient, logger *logrus.Logger) {
+    // Called by main
+    mockk8sclient.EXPECT().SetProxyEnvVars().Return(nil).AnyTimes()
+
+    // Called by GetReadyState to make sure we're online
+    nodeList := v1.NodeList{}
+    mockk8sclient.EXPECT().ListNodes().Return(&nodeList, nil).Times(1)
+
+    // Called a lot
+    mockk8sclient.EXPECT().CreateEvent(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func (args ...string) {
+        logger.Infof("Fake creating event %+v", args);
+    }).AnyTimes()
+
+    // Called by GetReadyState to make sure we're online
+    csrs := certificatesv1.CertificateSigningRequestList{}
+    mockk8sclient.EXPECT().ListCsrs().Return(&csrs, nil).AnyTimes()
+
+    bmhs := metal3v1alpha1.BareMetalHostList{}
+    mockk8sclient.EXPECT().ListBMHs().Return(bmhs, nil).AnyTimes()
+
+    machines := machinev1beta1.MachineList{}
+    mockk8sclient.EXPECT().ListMachines().Return(&machines, nil).AnyTimes()
+
+    mockk8sclient.EXPECT().IsMetalProvisioningExists().Return(true, nil).AnyTimes()
+
+    // The controller looks at MCS pod logs to determine whether hosts downloaded ignition or not, so we fake the MCS pod logs
+    fakeMcsName := "swarm-mcs"
+    podListMcs := []v1.Pod{{ObjectMeta: metav1.ObjectMeta{Name: fakeMcsName}}}
+    mockk8sclient.EXPECT().GetPods(gomock.Any(), map[string]string{"k8s-app": "machine-config-server"}, gomock.Any()).Return(podListMcs, nil).AnyTimes()
+    mockk8sclient.EXPECT().GetPodLogs(gomock.Any(), fakeMcsName, gomock.Any()).Return(`192.168.254.154.(Ignition)`, nil).AnyTimes()
+
+    // The controller compares AI host objects to cluster Node objects (Either by name or by IP) to check which AI hosts are already
+    // joined as nodes. This fakes the node list so that check will pass
+    nodeListPopulated := v1.NodeList{
+        Items: []v1.Node {
+            {
+                ObjectMeta: metav1.ObjectMeta{
+                    Name: "fedora",
+                },
+            },
+        },
+    }
+    mockk8sclient.EXPECT().ListNodes().Return(&nodeListPopulated, nil).AnyTimes()
+
+    // The controller 
+    myselfName := "swarm-controller"
+    podListMyself := []v1.Pod{{ObjectMeta: metav1.ObjectMeta{Name: myselfName}}}
+    mockk8sclient.EXPECT().GetPods(gomock.Any(), map[string]string{"job-name": "assisted-installer-controller"}, gomock.Any()).Return(podListMyself, nil).AnyTimes()
+
+    b := bytes.NewBufferString(`Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm
+Swarm`)
+
+    mockk8sclient.EXPECT().GetPodLogsAsBuffer(gomock.Any(), gomock.Any(), gomock.Any()).Return(b, nil).AnyTimes()
+}
+
 func main() {
 	logger := logrus.New()
 
@@ -41,11 +119,14 @@ func main() {
 
 	logger.Infof("Start running Assisted-Controller. Configuration is:\n %s", secretdump.DumpSecretStruct(Options.ControllerConfig))
 
-	kc, err := k8s_client.NewK8SClient("", logger)
+    ctrl := gomock.NewController(GinkgoT())
+    kc := k8s_client.NewMockK8SClient(ctrl)
 	if err != nil {
 		log.Fatalf("Failed to create k8 client %v", err)
 	}
 
+	prepareSwarmMock(kc, logger)
+
 	err = kc.SetProxyEnvVars()
 	if err != nil {
 		log.Fatalf("Failed to set env vars for installer-controller pod %v", err)
@@ -70,8 +151,9 @@ func main() {
 
 	// No need to cancel with context, will finish quickly
 	// we should fix try to fix dns service issue as soon as possible
-	go assistedController.HackDNSAddressConflict(&wg)
-	wg.Add(1)
+	// Comment this part out so we don't have to adjust the mock for it, it's useless for swarm simulation
+	// go assistedController.HackDNSAddressConflict(&wg)
+	// wg.Add(1)
 
 	assistedController.SetReadyState()
 
diff --git a/src/ops/ops.go b/src/ops/ops.go
index 03abde2..a1c1820 100644
--- a/src/ops/ops.go
+++ b/src/ops/ops.go
@@ -183,7 +183,7 @@ func (o *ops) WriteImageToDisk(ignitionPath string, device string, progressRepor
 	allArgs := installerArgs(ignitionPath, device, extraArgs)
 	o.log.Infof("Writing image and ignition to disk with arguments: %v", allArgs)
 	_, err := o.ExecPrivilegeCommand(NewCoreosInstallerLogWriter(o.log, progressReporter, config.GlobalConfig.InfraEnvID, config.GlobalConfig.HostID),
-		"coreos-installer", allArgs...)
+		"swarm-installer", allArgs...)
 	return err
 }
 
@@ -233,7 +233,7 @@ func (o *ops) SetBootOrder(device string) error {
 	o.log.Info("Setting efibootmgr to boot from disk")
 
 	// efi-system is installed onto partition 2
-	_, err = o.ExecPrivilegeCommand(o.logWriter, "efibootmgr", "-v", "-d", device, "-p", "2", "-c", "-L", "Red Hat Enterprise Linux", "-l", o.getEfiFilePath())
+	// _, err = o.ExecPrivilegeCommand(o.logWriter, "efibootmgr", "-v", "-d", device, "-p", "2", "-c", "-L", "Red Hat Enterprise Linux", "-l", o.getEfiFilePath())
 	if err != nil {
 		o.log.Errorf("Failed to set efibootmgr to boot from disk %s, err: %s", device, err)
 		return err
