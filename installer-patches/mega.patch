diff --git a/Makefile b/Makefile
index b4940cd..fb26666 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,6 @@
-CONTAINER_COMMAND = $(shell if [ -x "$(shell which docker)" ];then echo "docker" ; else echo "podman";fi)
-INSTALLER := $(or ${INSTALLER},quay.io/ocpmetal/assisted-installer:stable)
-CONTROLLER :=  $(or ${CONTROLLER}, quay.io/ocpmetal/assisted-installer-controller:stable)
+CONTAINER_COMMAND = podman
+INSTALLER := $(or ${INSTALLER},quay.io/otuchfel/assisted-installer:swarm)
+CONTROLLER :=  $(or ${CONTROLLER}, quay.io/otuchfel/assisted-installer-controller:swarm)
 ROOT_DIR = $(shell dirname $(realpath $(firstword $(MAKEFILE_LIST))))
 NAMESPACE := $(or ${NAMESPACE},assisted-installer)
 GIT_REVISION := $(shell git rev-parse HEAD)
diff --git a/go.mod b/go.mod
index 34621e5..7f18d7b 100644
--- a/go.mod
+++ b/go.mod
@@ -47,6 +47,7 @@ replace (
 	k8s.io/api => k8s.io/api v0.19.2
 	k8s.io/apimachinery => k8s.io/apimachinery v0.19.2
 	k8s.io/client-go => k8s.io/client-go v0.19.2
+	github.com/irifrance/gini => github.com/go-air/gini v1.0.1
 	k8s.io/code-generator => k8s.io/code-generator v0.0.0-20200214080538-dc8f3adce97c
 	sigs.k8s.io/cluster-api-provider-aws => github.com/openshift/cluster-api-provider-aws v0.2.1-0.20201022175424-d30c7a274820
 	sigs.k8s.io/cluster-api-provider-azure => github.com/openshift/cluster-api-provider-azure v0.1.0-alpha.3.0.20201016155852-4090a6970205
diff --git a/go.sum b/go.sum
index 9da6317..56cbbf5 100644
--- a/go.sum
+++ b/go.sum
@@ -394,6 +394,7 @@ github.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm
 github.com/gin-gonic/gin v1.6.3/go.mod h1:75u5sXoLsGZoRN5Sgbi1eraJ4GU3++wFwWzhwvtwp4M=
 github.com/globalsign/mgo v0.0.0-20180905125535-1ca0a4f7cbcb/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=
 github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=
+github.com/go-air/gini v1.0.1/go.mod h1:swH5OTtiG/X/YrU06r288qZwq6I1agpbuXQOB55xqGU=
 github.com/go-bindata/go-bindata v3.1.2+incompatible/go.mod h1:xK8Dsgwmeed+BBsSy2XTopBn/8uK2HWuGSnA11C3Joo=
 github.com/go-bindata/go-bindata/v3 v3.1.3/go.mod h1:1/zrpXsLD8YDIbhZRqXzm1Ghc7NhEvIN9+Z6R5/xH4I=
 github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=
diff --git a/src/installer/installer.go b/src/installer/installer.go
index b555868..f183e0b 100644
--- a/src/installer/installer.go
+++ b/src/installer/installer.go
@@ -149,9 +149,9 @@ func (i *installer) InstallNode() error {
 	//update installation progress
 	i.UpdateHostInstallProgress(models.HostStageRebooting, "")
 	//reboot
-	if err = i.ops.Reboot(); err != nil {
-		return err
-	}
+	// if err = i.ops.Reboot(); err != nil {
+	// 	return err
+	// }
 	return nil
 }
 
@@ -207,35 +207,35 @@ func (i *installer) startBootstrap() error {
 		return err
 	}
 	ignitionFileName := "bootstrap.ign"
-	ignitionPath, err := i.getFileFromService(ignitionFileName)
+	_, err := i.getFileFromService(ignitionFileName)
 	if err != nil {
 		return err
 	}
 
 	// We need to extract pull secret from ignition and save it in docker config
 	// to be able to pull MCO official image
-	if err = i.ops.ExtractFromIgnition(ignitionPath, dockerConfigFile); err != nil {
-		return err
-	}
+	// if err = i.ops.ExtractFromIgnition(ignitionPath, dockerConfigFile); err != nil {
+	// 	return err
+	// }
 
-	err = i.extractIgnitionToFS(ignitionPath)
+	// err = i.extractIgnitionToFS(ignitionPath)
 	if err != nil {
 		return err
 	}
 
 	if i.HighAvailabilityMode != models.ClusterHighAvailabilityModeNone {
-		err = i.generateSshKeyPair()
+		// err = i.generateSshKeyPair()
 		if err != nil {
 			return err
 		}
-		err = i.ops.CreateOpenshiftSshManifest(assistedInstallerSshManifest, sshManifestTmpl, sshPubKeyPath)
+		// err = i.ops.CreateOpenshiftSshManifest(assistedInstallerSshManifest, sshManifestTmpl, sshPubKeyPath)
 		if err != nil {
 			return err
 		}
 	}
 
 	// reload systemd configurations from filesystem and regenerate dependency trees
-	err = i.ops.SystemctlAction("daemon-reload")
+	// err = i.ops.SystemctlAction("daemon-reload")
 	if err != nil {
 		return err
 	}
@@ -245,14 +245,14 @@ func (i *installer) startBootstrap() error {
 	   remove the work done by 30-local-dns-prepender. This will cause DNS issue in bootkube and it will fail to complete
 	   successfully
 	*/
-	err = i.checkLocalhostName()
+	// err = i.checkLocalhostName()
 	if err != nil {
 		i.log.Error(err)
 		return err
 	}
 
 	// restart NetworkManager to trigger NetworkManager/dispatcher.d/30-local-dns-prepender
-	err = i.ops.SystemctlAction("restart", "NetworkManager.service")
+	// err = i.ops.SystemctlAction("restart", "NetworkManager.service")
 	if err != nil {
 		i.log.Error(err)
 		return err
@@ -263,7 +263,7 @@ func (i *installer) startBootstrap() error {
 		return err
 	}
 
-	servicesToStart := []string{"bootkube.service", "approve-csr.service", "progress.service"}
+	servicesToStart := []string{}
 	for _, service := range servicesToStart {
 		err = i.ops.SystemctlAction("start", service)
 		if err != nil {
@@ -669,14 +669,14 @@ func (i *installer) cleanupInstallDevice() error {
 		return nil
 	}
 
-	err = i.ops.RemoveVG(vgName)
+	// err = i.ops.RemoveVG(vgName)
 	if err != nil {
 		return err
 	}
 
-	_ = i.ops.Wipefs(i.Device)
+	// _ = i.ops.Wipefs(i.Device)
 
-	return i.ops.RemovePV(i.Device)
+	return err // i.ops.RemovePV(i.Device)
 }
 
 func (i *installer) verifyHostCanMoveToConfigurationStatus(inventoryHostsMapWithIp map[string]inventory_client.HostData) {
@@ -743,7 +743,7 @@ func (i *installer) createSingleNodeMasterIgnition() (string, error) {
 		return "", err
 	}
 	i.Config.Role = string(models.HostRoleMaster)
-	err = i.updateSingleNodeIgnition(singleNodeMasterIgnitionPath)
+	// err = i.updateSingleNodeIgnition(singleNodeMasterIgnitionPath)
 	if err != nil {
 		return "", err
 	}
diff --git a/src/main/assisted-installer-controller/assisted_installer_main.go b/src/main/assisted-installer-controller/assisted_installer_main.go
index 73ec8d4..cfa3b55 100644
--- a/src/main/assisted-installer-controller/assisted_installer_main.go
+++ b/src/main/assisted-installer-controller/assisted_installer_main.go
@@ -9,6 +9,8 @@ import (
 
 	"github.com/kelseyhightower/envconfig"
 	assistedinstallercontroller "github.com/openshift/assisted-installer/src/assisted_installer_controller"
+	"github.com/golang/mock/gomock"
+	. "github.com/onsi/ginkgo"
 	"github.com/openshift/assisted-installer/src/inventory_client"
 	"github.com/openshift/assisted-installer/src/k8s_client"
 	"github.com/openshift/assisted-installer/src/ops"
@@ -17,6 +19,10 @@ import (
 	"github.com/openshift/assisted-service/models"
 	"github.com/openshift/assisted-service/pkg/secretdump"
 	"github.com/sirupsen/logrus"
+	"github.com/openshift/assisted-installer/src/common"
+
+	v1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 )
 
 // Added this way to be able to test it
@@ -31,6 +37,23 @@ var Options struct {
 
 const maximumErrorsBeforeExit = 3
 
+func prepareSwarmMock(mockk8sclient *k8s_client.MockK8SClient, logger *logrus.Logger) {
+    // Called by main
+    mockk8sclient.EXPECT().SetProxyEnvVars().Return(nil).AnyTimes()
+
+    // Called by GetReadyState to make sure we're online
+    mockk8sclient.EXPECT().ListNodes().Return(nil, nil).AnyTimes()
+
+    // Called a lot
+    mockk8sclient.EXPECT().CreateEvent(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(func (args ...string) {
+        logger.Infof("Fake creating event %+v", args);
+    }).AnyTimes()
+
+    mockk8sclient.EXPECT().GetPods("assisted-installer", gomock.Any(), "").Return([]v1.Pod{{TypeMeta: metav1.TypeMeta{},
+        ObjectMeta: metav1.ObjectMeta{Name: common.AssistedControllerPrefix + "aasdasd"},
+        Status:     v1.PodStatus{Phase: "Running"}}}, nil).Times(1)
+}
+
 func main() {
 	logger := logrus.New()
 
@@ -41,11 +64,14 @@ func main() {
 
 	logger.Infof("Start running Assisted-Controller. Configuration is:\n %s", secretdump.DumpSecretStruct(Options.ControllerConfig))
 
-	kc, err := k8s_client.NewK8SClient("", logger)
+    ctrl := gomock.NewController(GinkgoT())
+    kc := k8s_client.NewMockK8SClient(ctrl)
 	if err != nil {
 		log.Fatalf("Failed to create k8 client %v", err)
 	}
 
+	prepareSwarmMock(kc, logger)
+
 	err = kc.SetProxyEnvVars()
 	if err != nil {
 		log.Fatalf("Failed to set env vars for installer-controller pod %v", err)
@@ -62,7 +88,7 @@ func main() {
 		Options.ControllerConfig,
 		ops.NewOps(logger, false),
 		client,
-		kc,
+		nil,
 	)
 
 	var wg sync.WaitGroup
@@ -70,8 +96,9 @@ func main() {
 
 	// No need to cancel with context, will finish quickly
 	// we should fix try to fix dns service issue as soon as possible
-	go assistedController.HackDNSAddressConflict(&wg)
-	wg.Add(1)
+	// Comment this part out so we don't have to adjust the mock for it, it's useless for swarm simulation
+	// go assistedController.HackDNSAddressConflict(&wg)
+	// wg.Add(1)
 
 	assistedController.SetReadyState()
 
diff --git a/src/ops/ops.go b/src/ops/ops.go
index 03abde2..a1c1820 100644
--- a/src/ops/ops.go
+++ b/src/ops/ops.go
@@ -183,7 +183,7 @@ func (o *ops) WriteImageToDisk(ignitionPath string, device string, progressRepor
 	allArgs := installerArgs(ignitionPath, device, extraArgs)
 	o.log.Infof("Writing image and ignition to disk with arguments: %v", allArgs)
 	_, err := o.ExecPrivilegeCommand(NewCoreosInstallerLogWriter(o.log, progressReporter, config.GlobalConfig.InfraEnvID, config.GlobalConfig.HostID),
-		"coreos-installer", allArgs...)
+		"swarm-installer", allArgs...)
 	return err
 }
 
@@ -233,7 +233,7 @@ func (o *ops) SetBootOrder(device string) error {
 	o.log.Info("Setting efibootmgr to boot from disk")
 
 	// efi-system is installed onto partition 2
-	_, err = o.ExecPrivilegeCommand(o.logWriter, "efibootmgr", "-v", "-d", device, "-p", "2", "-c", "-L", "Red Hat Enterprise Linux", "-l", o.getEfiFilePath())
+	// _, err = o.ExecPrivilegeCommand(o.logWriter, "efibootmgr", "-v", "-d", device, "-p", "2", "-c", "-L", "Red Hat Enterprise Linux", "-l", o.getEfiFilePath())
 	if err != nil {
 		o.log.Errorf("Failed to set efibootmgr to boot from disk %s, err: %s", device, err)
 		return err
